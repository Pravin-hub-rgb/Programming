<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>l-4 =Best Case, Worst Case and Average Case Analysis of an Algorithm </title>
    <link rel="stylesheet" href="../styleLesson.css">
</head>

<body>
    <div id="mySidepanel" class="sidepanel">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">Ã—</a>
        <a href="../index.html" class="home">Home</a>
        <a href="#" class="link"></a>
    </div>
    <div id="navbar" class="grad">
        <div>
            <div class="openbtn" onclick="openNav()">
                <div id="nav-icon1" for="nav-menu1">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div>
            <h2>Data Structures and Algorithms</h2>
        </div>
    </div>
    <div class="content-box">
        <h1>Best Case, Worst Case and Average Case Analysis of an Algorithm</h1>
        <div class="inside-content">
            <h2> Analysis of a search algorithm:</h2>
            <p>
                Consider an array that is sorted in increasing order.
                <br>1 7 18 50 180
                <br>We have to search a given number in this array and report whether it's present in the array or not. In this case, we have two algrotithms, and we will be interested in analyzing their performance separately.
                <br><br><b>Algorithm 1 -</b> Start from the first element until an element greater than or equal to the number to sbe searched is found.
                <br><b>Algorithm 2 -</b> Check whether the first or the last element is equal to the number. If not, find the number between these two elements (center of the array); if the center element is greater than the number to be searched, repeat
                the process for the first half else, repeat for the second half until the number is found. And this way, keep dividing your search space, making it faster to search.
            </p>
            <div class="in">
                <h3>Analyzing Algorithm 1: (Linear Search)</h3>
                <p>
                    We might get lucky enough to find our element to be the first element of the array. Therefore, we only made one comparison which is obviously constant for any size of the array.
                </p>
                <div class="wh">
                    <p>Best case complexity = O(1)</p>
                </div>
                <p>
                    If we are not hte afortunate, the element we are searching for might be the last one. Therefore, our program made 'n' comparisions.
                </p>
                <div class="wh">
                    <p>Worst case complexity = O(n)</p>
                </div>
                <p>
                    For calculating the average case time, we sum the list of all the possible case's runtime and divide it with the toatal number of cases. Here, we found it to be just O(n). (Sometimes, calculation of average-case time gets very complicated.)
                </p>
            </div>
            <div class="in">
                <h3>Analyzing Algorithm 2: </h3>
                <p>
                    If we get really lucky, the first element will be the only element that gets comparedd. Hence, a constatnt time.
                </p>
                <div class="wh">
                    <p>Best case comlexity = O(1)</p>
                </div>
                <p>If we get unlucky, we will have to keep dividing the array into halves until we get a single element. (that is, the array gets finished) <br><br>Hence the time taken : n + n/2 + n/4 + ..... +1 = logn with base 2</p>
                <div class="wh">
                    <p>Worst case complexity = O(log n) </p>
                </div>
                <div class="in">
                    <h3>What is log(n)?</h3>
                    <p>
                        Logn refers to how many times I need to divide n units until they can no longer ve divided (into halves).
                        <ul>
                            <li>
                                log8 = 3 &rarr; 8/2 + 4/3 + 2/2 &rarr; can't break anymore
                            </li>
                            <li>
                                Log 4 = 2 &rarr; 4/2 + 2/2 &rarr; can't break anymore.
                            </li>
                        </ul>
                        You can refer to the graph below, and you will find how slowly the time complexity (y-axis) increases when we increase the input n (X-axis).
                        <img src="../images/logn.jpg" alt="">
                    </p>
                </div>
            </div>

        </div>
        <div class="inside-content">
            <h2>Space complexity</h2>
            <ul>
                <li>Time is not the only thing we worry about while analyzing algorithms. Space is equally important.</li>
                <li>Creating an array of size n (size of the input) &rarr; O (n) Space</li>
                <li>If a function calls inself recursively n times, its space complexity is O(n).</li>
            </ul>
        </div>
    </div>
    <script src="../main.js"></script>
</body>

</html>